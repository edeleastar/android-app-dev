 <!DOCTYPE html>
 <html>
   <head>

     <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>

     <meta charset="utf-8">
     <meta name="viewport" content="width=device-width, initial-scale=1">

     <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.1.4/semantic.min.css" type="text/css">
     <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.2/styles/solarized_light.min.css" rel="stylesheet" />

     <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
     <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.address/1.6/jquery.address.min.js"></script>
     <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.1.4/semantic.min.js"></script>
     <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.2/highlight.min.js"></script>
     <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.2/languages/java.min.js"></script>
     <script>hljs.initHighlightingOnLoad();</script>

      <style>


body 
{
  font-family: "Open Sans", "Helvetica", "Helvetica Neue",  "Arial", sans-serif;
}

figcaption
{
  margin-bottom: 20px;
}

.vertical-align
{
  display: flex;
  align-items: center;
}

.credits
{
  min-height:20px;
}
    </style>

  </head>

  <body>

  <div class="ui container">
<style>


code
{
  font-family: "Monaco";
  font-size: 110%;
}

img
{
  padding:1px;
  border:1px solid black;
}

h1
{
  font-style:italic;
  font-size:130%;
  border-bottom: thin solid black;
}
h2
{
  font-size:110%;
  border-bottom: thin solid black;
}
h3
{
  font-size:100%;
  border-bottom: thin solid black;
}

</style>

<div class="ui fixed sticky top attached tabular menu labmenu">
   <header class="header item">
    <a href="../index.html">12: Services </a>
  </header>
    <a class="active item" data-tab="MyTweet-Assignment-02">
        MyTweet-Assignment-02
    </a>
      <a class="item" data-tab="01">
        01
      </a>
      <a class="item" data-tab="02">
        02
      </a>
      <a class="item" data-tab="03">
        03
      </a>
      <a class="item" data-tab="04">
        04
      </a>
      <a class="item" data-tab="05">
        05
      </a>
      <a class="item" data-tab="06">
        06
      </a>
      <a class="item" data-tab="07">
        07
      </a>
      <a class="item" data-tab="08">
        08
      </a>
      <a class="item" data-tab="09">
        09
      </a>
      <a class="item" data-tab="10">
        10
      </a>
      <a class="item" data-tab="11">
        11
      </a>
</div>


<div id="labcontent" class="ui bottom attached tab segment lab" data-tab="MyTweet-Assignment-02">
  <h1>Introduction</h1>
<p>This is a follow-on lab to MyTweet-Assignment-01. The lab provides guidance but <span style="color:red">not comprehensive instructions</span> (which is reasonable given that it relates to an assignment). The guidance addesses issues that might otherwise prove quite difficult to resolve.</p>
</div>
<div id="labcontent" class="ui bottom attached tab segment lab" data-tab="01">
  <h1>Preview</h1>
<p>The aim of the previous lab was to facilitate the creation of a walking skeleton of the baseline Android MyTweet app, the subject of the second and final Mobile Application Development assignment.</p>
<p>In this lab we further develop MyTweet Android client and Play service by introducing a User model and establishing a many-to-one bi-directional relationship between User and Tweet models.</p>
<ul>
<li>Introduce a User model</li>
<li>Modify the existing Tweet model</li>
<li>Modify the Welcome activity by the addition of buttons to allow a user to access sign up and log in views.</li>
</ul>
<p>It is necessary to have completed the projects in the previous lab and to use these as a starting point in this lab:</p>
<ul>
<li>mytweet-app</li>
<li>mytweet-service</li>
<li>mytweet-service-test</li>
</ul>
<p>There are differences in the sample archive code provided here compared to the previous assignment studio lab (MyTweet-01). </p>
<p>One important difference relates to file <strong>JsonParsers.java</strong> in the service app (MyTweetService):</p>
<ul>
<li>In this lab we use <em>flexjson</em> library in <span style="color:red">mytweet-service</span>: it is essential that you do also here.</li>
<li>This library is necessary because of the <em>OneToMany</em> relationship that is now used in the User-Tweet model pair.</li>
<li>However, it is simpler to use <a href="archives/gson-2.2.4.jar"><em>gson</em></a> in both the Android client (mytweet-app) and the JUnit test code.<ul>
<li>The sample code downloadable below follows these recommendations.</li>
<li>This has been verified on a corresponding Android client used in the preparation of this lab (not available to download).</li>
</ul>
</li>
</ul>
<p>As a consequence, in mytweet-service, you should modify the file <strong>dependencies.yml</strong> in the <strong>conf</strong> folder to read as follows:</p>
<pre><code># Application dependencies
require:
    - play
    - net.sf.flexjson -&gt; flexjson 3.2
</code></pre>

<p>Here are working sample apps that you may find helpful:</p>
<ul>
<li><a href="archives/mytweet-service.zip">mytweet-service</a></li>
<li><a href="archives/mytweet-service-test.zip">mytweet-service-test</a></li>
</ul>
<p>Recall again how to eliminate build path errors in an imported Play app archive (these errors are usually indicated by the presence of a red exclamation mark to the left of the project name in the Eclipse workspace):</p>
<ul>
<li>Import the archive into Eclipse</li>
<li>Delete the <strong>eclipse</strong> folder</li>
<li>In a terminal cd to the root of the Play app and run successively:</li>
</ul>
<pre><code>play eclipsify
play deps
</code></pre>

<p>Finally, refresh the project in the Eclipse workspace (highlight project name and press F5 or right click to reveal context menu and select <em>Refresh</em> ).</p>
</div>
<div id="labcontent" class="ui bottom attached tab segment lab" data-tab="02">
  <h1>MyTweetService (User)</h1>
<p>We shall develop a User model class in this step.</p>
<p>We establish a relationship with the Tweet model as follows:</p>
<pre><code>  @OneToMany(mappedBy=&quot;user&quot;,cascade = CascadeType.ALL)
  public List&lt;Tweet&gt; tweets = new ArrayList&lt;Tweet&gt;();
</code></pre>

<p>What this is expressing is that:</p>
<ul>
<li>a single user may own many tweets</li>
<li>User stores the tweets in a list named <em>tweets</em></li>
<li>any particular tweet will have a reference to its owning user<ul>
<li>this will be represented as <em>User user</em> field in Tweet class which we shall see shortly.</li>
</ul>
</li>
</ul>
<p>Here is the new User model code including the above snippet. We are familiar with most aspects of this User class from previous labs such as, for example, Donation.</p>
<p>Note that we are generating the id (uuid) in the client as we did with the Tweet model.</p>
<p>File: User.java</p>
<pre><code>package models;

import java.util.ArrayList;
import java.util.List;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.Table;

import play.db.jpa.GenericModel;

/**
 * User has been escaped: This is necessary because User is a reserved word in PostGreSQL
 * However, if working in local host and wish to use localhost:9000/@db (for example) to view database
 * Then it is necessary to temporarily comment out the line (i.e. @Table(name = &quot;`User`&quot;) while testing with local host
 *
 */
@Entity
@Table(name=&quot;`User`&quot;) //To facilitate deployment to heroku: comment out if required to inspect localhost:9000/@db
public class User extends GenericModel
{
  @Id
  @Column(name=&quot;id&quot;)
  public String uuid;
  public String firstName;
  public String lastName;
  public String email;
  public String password;

  @OneToMany(mappedBy=&quot;user&quot;,cascade = CascadeType.ALL)
  public List&lt;Tweet&gt; tweets = new ArrayList&lt;Tweet&gt;();

  public User(String uuid, String firstName, String lastName, String email, String password)
  {
    this.uuid     = uuid;
    this.firstName= firstName;
    this.lastName = lastName;
    this.email    = email;
    this.password = password;
  }

  public static User findByEmail(String email)
  {
    return find(&quot;email&quot;, email).first();
  }  

  public boolean checkPassword(String password)
  {
    return this.password.equals(password);
  } 
}
</code></pre>
</div>
<div id="labcontent" class="ui bottom attached tab segment lab" data-tab="03">
  <h1>MyTweetService (Tweet)</h1>
<p>The only change to the Tweet model is the addition of the other side of the relationship introduced in User:</p>
<pre><code>  @ManyToOne
  public User user;
</code></pre>

<p>A user may own (create) many tweets but a tweet will always have been created by a single user.</p>
<p>Here is the complete class:</p>
<pre><code>package models;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.ManyToOne;

import play.db.jpa.GenericModel;

@Entity
public class Tweet extends GenericModel
{
  @Id
  @Column(name=&quot;id&quot;)
  public String uuid;
  public String message;
  public String datestamp;
  @ManyToOne
  public User user;

  public Tweet(String uuid, String message, String datestamp)
  {
    this.uuid       = uuid;
    this.message    = message;
    this.datestamp  = datestamp;
  }
}

</code></pre>

<p>Replace the routes file with an updated version that accommodates the new User model:</p>
<pre><code># Routes
# This file defines all application routes (Higher priority routes first)
# ~~~~

GET     /                                     Application.index

GET     /api/users                            UsersAPI.users
GET     /api/users/{id}                       UsersAPI.user
POST    /api/users                            UsersAPI.createUser
DELETE  /api/users/{id}                       UsersAPI.deleteUser
DELETE  /api/users                            UsersAPI.deleteAllUsers

GET     /api/users/{userId}/tweets            TweetsAPI.tweets
GET     /api/users/{userId}/tweet/{id}        TweetsAPI.tweet
POST    /api/users/{userId}/tweets            TweetsAPI.createTweet
DELETE  /api/users/{userId}/tweets/{id}       TweetsAPI.deleteTweet
DELETE  /api/users/{userId}/tweets            TweetsAPI.deleteAllTweets

# Ignore favicon requests
GET     /favicon.ico                            404

# Map static resources from the /app/public folder to the /public path
GET     /public/                                staticDir:public

# Catch all
*       /{controller}/{action}                  {controller}.{action}
</code></pre>
</div>
<div id="labcontent" class="ui bottom attached tab segment lab" data-tab="04">
  <h1>MyTweetService(APIs)</h1>
<h2>JsonParsers</h2>
<p>Here is the JsonParsers file updated with User conversion code:</p>
<pre><code>package utils;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import flexjson.JSONDeserializer;
import flexjson.JSONSerializer;
import models.Tweet;
import models.User;

public class JsonParsers
{
  public static JSONSerializer userSerializer     = new JSONSerializer().exclude(&quot;class&quot;)
                                                                        .exclude(&quot;persistent&quot;)
                                                                        .exclude(&quot;entityId&quot;)
                                                                        .exclude(&quot;tweets&quot;);
  public static JSONSerializer TweetSerializer    = new JSONSerializer().exclude(&quot;class&quot;)
                                                                        .exclude(&quot;persistent&quot;)
                                                                        .exclude(&quot;entityId&quot;);  
  public static User json2User(String json)
  {
    return new JSONDeserializer&lt;User&gt;().deserialize(json, User.class); 
  }

  public static List&lt;User&gt; json2Users(String json)
  {
    return new JSONDeserializer&lt;ArrayList&lt;User&gt;&gt;().use(&quot;values&quot;, User.class).deserialize(json);
  }

  public static String user2Json(Object obj)
  {
    return userSerializer.serialize(obj);
  }

  public static List&lt;User&gt; users2Json(String json)
  {
    return new JSONDeserializer&lt;ArrayList&lt;User&gt;&gt;().use(&quot;values&quot;, User.class).deserialize(json);
  } 


  public static Tweet json2Tweet(String json)
  {
    return  new JSONDeserializer&lt;Tweet&gt;().deserialize(json, Tweet.class);    
  }

  public static String tweet2Json(Object obj)
  {
    return TweetSerializer.serialize(obj);
  }  

  public static List&lt;Tweet&gt; json2Tweets(String json)
  {
    return new JSONDeserializer&lt;ArrayList&lt;Tweet&gt;&gt;().use(&quot;values&quot;, Tweet.class).deserialize(json);
  }  
}
</code></pre>

<h2>UsersAPI</h2>
<p>Add an API for User class:</p>
<p>File: UsersAPI.java</p>
<pre><code>package controllers;

import play.*;
import play.mvc.*;
import utils.JsonParsers;

import java.util.*;

import com.google.gson.JsonElement;

import models.*;

public class UsersAPI extends Controller
{
  public static void users()
  {
    List&lt;User&gt; users = User.findAll();
    renderJSON(JsonParsers.user2Json(users));
  }

  public static void user(String id)
  {
    User user = User.findById(id);  
    if (user == null)
    {
      notFound();
    }
    else 
    {
      renderJSON(JsonParsers.user2Json(user));
    }
  }

  public static void createUser(JsonElement body)
  {
    User user = JsonParsers.json2User(body.toString());
    user.save();
    renderJSON(JsonParsers.user2Json(user));
  }

  public static void deleteUser(String id)
  {
    User user = User.findById(id);
    if (user == null)
    {
      notFound();
    }
    else
    {
      List&lt;Tweet&gt; tweets = user.tweets;
      for(int j = 0; j &lt; tweets.size(); j += 1)
      {
        Tweet tweet = Tweet.findById(tweets.get(j).uuid);
        user.tweets.remove(tweet);
        user.save();
        tweet.delete();
      }
      user.delete();      
      renderText(&quot;success&quot;);
    }
  }

  public static void deleteAllUsers()
  {
    List&lt;User&gt; users = User.findAll();
    for(int i = 0; i &lt; users.size(); i += 1)
    {
      User user = users.get(i);
      List&lt;Tweet&gt; tweets = user.tweets;
      for(int j = 0; j &lt; tweets.size(); j += 1)
      {
        Tweet tweet = Tweet.findById(tweets.get(j).uuid);
        user.tweets.remove(tweet);
        user.save();
        tweet.delete();
      }
      user.delete();
    }
    renderText(&quot;success&quot;);
  }     
}


</code></pre>

<p>For reference, here is the TweetsAPI:</p>
<pre><code>package controllers;

import java.util.List;
import java.util.Random;

import models.Tweet;
import models.User;
import play.Logger;
import play.mvc.Controller;
import utils.JsonParsers; 

import com.google.gson.JsonElement;

public class TweetsAPI extends Controller
{
  /**
   * retrieve all tweets
   */
  public static void tweets(String userId)
  {
    User user = User.findById(userId);
    if(user == null)
    {
      notFound();
    }
    else
    {
      List&lt;Tweet&gt; tweets = user.tweets;
      renderJSON(JsonParsers.tweet2Json(tweets));
    }
  }

  public static void tweet(String id)
  {
    Tweet tweet = Tweet.findById(id);  
    if (tweet == null)
    {
      notFound();
    }
    else
    {
      renderJSON(JsonParsers.tweet2Json(tweet));
    }
  }

  public static void createTweet(String userId, JsonElement body)
  {
    Tweet tweet = JsonParsers.json2Tweet(body.toString());
    User user = User.findById(userId);
    user.tweets.add(tweet);
  tweet.user = user;
    tweet.save();
    renderJSON(JsonParsers.tweet2Json(tweet));
  }

  public static void deleteTweet(String id)
  {
    Tweet tweet = Tweet.findById(id);
    if (tweet == null)
    {
      notFound();
    }
    else
    {
      tweet.delete();
      renderText(&quot;success&quot;);
    }
  }

  public static void deleteAllTweets()
  {
    Tweet.deleteAll();
    renderText(&quot;success&quot;);
  }  

}
</code></pre>
</div>
<div id="labcontent" class="ui bottom attached tab segment lab" data-tab="05">
  <h1>Deletion</h1>
<p>You are recommended to study and understand how Tweets and Users are deleted in the API files.</p>
<ul>
<li>Deleting tweets is straightforward as shown here in figure 1.</li>
</ul>
<p><img alt="Figure 1: Deleting all Tweets" src="img/15.png"></p>
<ul>
<li>But deleting users is much more complex. This is apparent in Figure 2.<ul>
<li>This complexity is caused by the many-to-one relationship between tweets and users:<ul>
<li>A User contains a list of tweets and so when a user is deleted it is necessary to ensure its associated tweets are also removed.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img alt="Figure 2: Deleting all Users" src="img/16.png"></p>
<p>Recall that we already encountered code like this in the WitPress lab.</p>
<ul>
<li>
<p><a href="archives/witpress-v1.zip">WitPress (solution v1: step 5)</a></p>
</li>
<li>
<p>Figure 3 adds to Figure 2 by providing explanatory comments.</p>
</li>
</ul>
<p><img alt="Figure 3: Deleting all users explained" src="img/17.png"></p>
<p>Figure 4 shows the methods to create a tweet and a user side-by-side with the deleteAllUsers method:</p>
<p><img alt="Figure 4: createUser, createTweet and deleteAllUsers methods" src="img/18.png"></p>
</div>
<div id="labcontent" class="ui bottom attached tab segment lab" data-tab="06">
  <h1>Routes &amp; APIs</h1>
<p>Now that you have added both routes and APIs, it is worthwhile taking a moment to study how the uri-api relationship works. </p>
<p>Consider this extract from the <em>routes</em> file:</p>
<p><img alt="Figure 1: Extract from routes file" src="img/08.png"></p>
<p>A typical application of the url portion of this could be:</p>
<p><img alt="Figure 2: Example of url used to GET tweet list" src="img/09.png"></p>
<p>Now examine the method TweetsAPI.tweets below. </p>
<p><img alt="Figure 3: TweetsAPI.tweets(...)" src="img/10.png"></p>
<p>Observe the argument <em>String  userId)</em>. The value passed in this argument is the user's uuid as shown in Figure 2.</p>
<p>Now study the more complex POST request shown here in Figure 4.</p>
<p><img alt="Figure 4: POST request to create a tweet" src="img/11.png"></p>
<ul>
<li>
<p>Item number 1 illustrates how the argument list in Rest.post() comprises a url and a JSON representaton of the tweet that we wish to create on the server.</p>
</li>
<li>
<p>Item number 2 is an extract from the routes file and shows that this request expects a method TweetAPI.createTweet to be available to invoke server-side.</p>
</li>
<li>
<p>Item number 3 shows the method TweetAPI.createTweet. Observer that there are two arguments, the first value obtained from the uri (the User uuid) and the second the JSON Tweet object.</p>
</li>
</ul>
</div>
<div id="labcontent" class="ui bottom attached tab segment lab" data-tab="07">
  <h1>MyTweetApp (Welcome)</h1>
<p>We have completed refactoring mytweet-service Play app and now address the Android mytweetapp client.</p>
<p>The legacy Welcome screen and its suggested replacement are shown here in Figure 1:</p>
<p><img alt="Figure 1: Legacy Welcome screen" src="img/01.png"></p>
<p>The refactored Welcome screen and new Login and Signup screens are depicted in Figure 2.</p>
<p><img alt="Figure 2: Refactored Welcome" src="img/02.png"></p>
</div>
<div id="labcontent" class="ui bottom attached tab segment lab" data-tab="08">
  <h1>MyTweetApp(Model)</h1>
<p>The model classes used in the Android client, MyTweetApp are introduced in this step.</p>
<h2>Tweet</h2>
<p>The Tweet model class remains unchanged. No relationship between Tweet and User will exist in the client. </p>
<ul>
<li>Such a relationship does, however, exist on the Play service app.</li>
</ul>
<h2>User</h2>
<p>Here is the new User model class. Observe that the <em>uuid</em> is generated here rather than in the Play app on the server.</p>
<ul>
<li>The server obtains the uuid by parsing the url:<ul>
<li>For example : <em>GET     /api/users/{userId}/tweets  TweetsAPI.tweets</em></li>
</ul>
</li>
<li>This behaviour mirrors that adopted by us in Tweet model class.</li>
<li>In Donations labs, however, the conventional approach of allowing the service Play app to generate the uuid (the primary key) is adopted.</li>
</ul>
<pre><code>package org.wit.mytweet.model;

import java.util.UUID;

public class User 
{
  public String uuid;
  public String firstName;
  public String lastName;
  public String email;
  public String password;

  public User()
  {}

  public User(String firstName, String lastName, String email, String password)
  {
    this.uuid      = UUID.randomUUID().toString();
    this.firstName = firstName;
    this.lastName  = lastName;
    this.email     = email;
    this.password  = password;
  } 

}
</code></pre>
</div>
<div id="labcontent" class="ui bottom attached tab segment lab" data-tab="09">
  <h1>MyTweetApp(API)</h1>
<p>Here are sample APIs for both User and Tweet in the Android client (MyTweetApp):</p>
<p>File: TweetsAPI.java</p>
<pre><code>package org.wit.mytweets.controllers;

import java.util.List;

import org.wit.mytweet.http.Request;
import org.wit.mytweet.http.Response;
import org.wit.mytweet.http.Rest;
import org.wit.mytweet.httputils.JsonParsers;
import org.wit.mytweet.model.Tweet;
import org.wit.mytweet.model.User;

import android.content.Context;

public class TweetsAPI
{ 
  public static void getTweets(Context context, Response&lt;Tweet&gt; response, String dialogMesssage, User user)
  {
    new GetTweets(context, response, dialogMesssage).execute(user);
  }

  public static void createTweet(Context context, Response&lt;Tweet&gt; response, String dialogMesssage, User user, Tweet tweet)
  {
    new CreateTweet(context, response, dialogMesssage).execute(user,tweet);
  }

  public static void deleteTweet(Context context, Response&lt;Tweet&gt; response, String dialogMesssage, User user, Tweet tweet)
  {
    new DeleteTweet(context, response, dialogMesssage).execute(user, tweet);
  }
}

class GetTweets extends Request
{
  public GetTweets(Context context, Response&lt;Tweet&gt; callback, String message)
  {
    super(context, callback, message);
  }

  @Override
  protected List&lt;Tweet&gt; doRequest(Object... params) throws Exception
  {
    String userId = ((User)params[0]).uuid;
    String response =  Rest.get(&quot;/api/users/&quot; + userId + &quot;/tweets&quot;);
    List&lt;Tweet&gt; tweetList = JsonParsers.json2Tweets(response);
    return tweetList;
  }
}

class CreateTweet extends Request
{
  public CreateTweet(Context context, Response&lt;Tweet&gt; callback, String message)
  {
    super(context, callback, message);
  }

  @Override
  protected Tweet doRequest(Object... params) throws Exception
  {
    String userId = ((User)params[0]).uuid;
    String response = Rest.post (&quot;/api/users/&quot; + userId + &quot;/tweets&quot;, JsonParsers.tweet2Json(params[1]));
    return JsonParsers.json2Tweet(response);
  }
}

class DeleteTweet extends Request 
{
  public DeleteTweet(Context context, Response&lt;Tweet&gt; callback, String message)
  {
    super(context, callback, message);
  }

  @Override 
  protected Tweet doRequest(Object... params) throws Exception

  {
  User user = ((User)params[0]);
    String tweetId = ((Tweet)params[1]).getId().toString();
    String path    = &quot;/api/users/&quot; + user.uuid + &quot;/tweets/&quot; + tweetId; 
    String response = Rest.delete (path);
    if(response.equals(&quot;success&quot;))
    {
      return new Tweet();//String not acceptable argument to any of Response methods so we fake it
    }
    else
    {
      throw new Exception();
    }
  }
}


</code></pre>

<p>File: UsersAPI.java</p>
<pre><code>package org.wit.mytweets.controllers;

import java.util.List;

import org.wit.mytweet.http.Request;
import org.wit.mytweet.http.Response;
import org.wit.mytweet.http.Rest;
import org.wit.mytweet.httputils.JsonParsers;
import org.wit.mytweet.model.User;

import android.content.Context;

public class UsersAPI
{ 
  public static void getUsers(Context context, Response&lt;User&gt; response, String dialogMesssage)
  {
    new GetUsers(context, response, dialogMesssage).execute();
  }

  public static void createUser(Context context, Response&lt;User&gt; response, String dialogMesssage, User user)
  {
    new CreateUser(context, response, dialogMesssage).execute(user);
  }

  public static void deleteUser(Context context, Response&lt;User&gt; response, String dialogMesssage, User user)
  {
    new DeleteUser(context, response, dialogMesssage).execute(user);
  }
}
//===============================================================================================================//
class GetUsers extends Request
{
  public GetUsers(Context context, Response&lt;User&gt; callback, String message)
  {
    super(context, callback, message);
  }

  @Override
  protected List&lt;User&gt; doRequest(Object... params) throws Exception
  {
    String response =  Rest.get(&quot;/api/users&quot;);
    List&lt;User&gt; userList = JsonParsers.json2Users(response);
    return userList;
  }
}

class CreateUser extends Request
{
  public CreateUser(Context context, Response&lt;User&gt; callback, String message)
  {
    super(context, callback, message);
  }

  @Override
  protected User doRequest(Object... params) throws Exception
  {
    String response = Rest.post (&quot;/api/users&quot;, JsonParsers.user2Json(params[0]));
    return JsonParsers.json2User(response);
  }
}

class DeleteUser extends Request 
{
  public DeleteUser(Context context, Response&lt;User&gt; callback, String message)
  {
    super(context, callback, message);
  }

  @Override 
  protected User doRequest(Object... params) throws Exception

  {
    String id = ((User)params[0]).uuid.toString();
    String path = &quot;/api/users/&quot; + id; 
    String response = Rest.delete (path);
    if(response.equals(&quot;success&quot;))
    {
      return new User();
    }
    else
    {
      throw new Exception();
    }
  }
}


</code></pre>

<p>Add User parsers to JsonParsers.java which should eliminate the errors flagged when the above code is introduced:</p>
<pre><code>  public static User json2User(String json)
  {
    return gson.fromJson(json, User.class);   
  }

  public static List&lt;User&gt; json2Users(String json)
  {
    Type collectionType = new TypeToken&lt;List&lt;User&gt;&gt;() {}.getType();
    return gson.fromJson(json, collectionType); 
  }

  public static String user2Json(Object obj)
  {
    return gson.toJson(obj);
  } 
</code></pre>

<p>Here, for reference, is the complete <em>JsonParsers.java</em> file:</p>
<pre><code>package org.wit.mytweet.httputils;

import java.lang.reflect.Type;
import java.util.List;

import org.wit.mytweet.model.Tweet;
import org.wit.mytweet.model.User;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

public class JsonParsers
{
  static Gson gson = new Gson(); 
  //===================User=====================//
  public static User json2User(String json)
  {
    return gson.fromJson(json, User.class);   
  }

  public static List&lt;User&gt; json2Users(String json)
  {
    Type collectionType = new TypeToken&lt;List&lt;User&gt;&gt;() {}.getType();
    return gson.fromJson(json, collectionType); 
  }

  public static String user2Json(Object obj)
  {
    return gson.toJson(obj);
  } 

  //===============Tweet========================//
  public static Tweet json2Tweet(String json)
  {
    return gson.fromJson(json, Tweet.class);   
  }

  public static List&lt;Tweet&gt; json2Tweets(String json)
  {
    Type collectionType = new TypeToken&lt;List&lt;Tweet&gt;&gt;() {}.getType();
    return gson.fromJson(json, collectionType); 
  }

  public static String tweet2Json(Object obj)
  {
    return gson.toJson(obj);
  }
}
</code></pre>
</div>
<div id="labcontent" class="ui bottom attached tab segment lab" data-tab="10">
  <h1>MyTweetApp (Integration)</h1>
<p>Some changes are required to accomodate the new User class and its relationship with Tweet.</p>
<p><strong>Signup</strong> and <strong>Login</strong></p>
<p>It is assumed you have already introduced and fully implemented these activities.</p>
<p><strong>MyTweetApp</strong></p>
<ul>
<li>It will be necessary to introduce a field here to store the current user.</li>
<li>This field should be initialized from the Login activity (once a user has been authenticated).</li>
</ul>
<pre><code>public User logged_in_user;
</code></pre>

<p>Also required is a field for the current list of users:</p>
<pre><code>  public List &lt;User&gt; users = new ArrayList&lt;User&gt;();  
</code></pre>

<p>And a method to authenticate:</p>
<pre><code>  public User validUser (String email, String password)
  {
    for (User user : users)
    {
      if (user.email.equals(email) &amp;&amp; user.password.equals(password))
      {
        logged_in_user = user;
        return user;
      }
    }
    return null;
  }
</code></pre>

<p><strong>TimeLineFragment</strong></p>
<p>Add User &amp; MyTweetApp fields:</p>
<pre><code>private User user;
private MyTweetApp app;
</code></pre>

<p>Initialize <em>user</em> in onCreate:</p>
<pre><code>@Override
  public void onCreate(Bundle savedInstanceState)
  {
    super.onCreate(savedInstanceState);
    ...
    app = (MyTweetApp) getActivity().getApplication();
    user   = app.logged_in_user;
    ...
  }
</code></pre>

<p>Modify the TweetsAPI.deleteTweet invocations to include a <em>User</em> instance:</p>
<pre><code>TweetsAPI.deleteTweet(getActivity(), this, &quot;deleting tweet&quot;, user, tweet);
</code></pre>

<h2>MyTweetFragment</h2>
<p>Replace the call in <em>onClick</em> to create a tweet with the following in which <em>user</em> has been introduced as an argument:</p>
<pre><code>  public void onClick(View v)
  {
    switch (v.getId())
    {
      case R.id.tweet_button:
        User user = app.logged_in_user;
        if(user != null)
        {
          TweetsAPI.createTweet(getActivity(), this, &quot;tweeting&quot;, user, this_tweet);
        }
        else
        {
          Toast.makeText(getActivity(), &quot;Unable to locate logged-in user&quot;, Toast.LENGTH_SHORT).show();
        }
        break;
    }
  }
</code></pre>
</div>
<div id="labcontent" class="ui bottom attached tab segment lab" data-tab="11">
  <h1>Test</h1>
<p>As part of the assignment you will be writing and executing comprehensive JUnit tests. </p>
<p>Here, in the meantime, are some quick checks you may perform using Postman:</p>
<p>Create a new user.
Create some tweets associated with the user.</p>
<p>Repeat for a second user.</p>
<ul>
<li>GET the users</li>
<li>GET a specific user using the user id from the previous test</li>
<li>GET the tweets for a specific user</li>
<li>DELETE all users<ul>
<li>Use the H2 console (localhost:9000/@db) to verify the associated tweets have also been deleted</li>
</ul>
</li>
<li>Replace the deleted users and DELETE the users individually</li>
</ul>
<p>Here is a typical url to to retrieve the list of tweets for a specific user:
<img alt="" src="img/14.png">
Note that if you wish to use the H2 console to view the User table it will be necessary to comment out the following line in model User.java:</p>
<pre><code>@Table(name=&quot;`User`&quot;)
</code></pre>

<p>Do not forget to restore this line when deploying to Heroku as a workaround since User is a reserved word in PostgreSql.</p>
<p>Here are screenshot of some tests results:</p>
<p><img alt="Figure 1: H2 Console used to check User and Tweet" src="img/06.png">
<img alt="Figure 2: Get all users" src="img/03.png">
<img alt="Figure 3: Get all tweets for a specific user" src="img/04.png">
<img alt="Figure 4: Delete all users" src="img/05.png"></p>
<p>Consult the routes file as you conduct the tests to ensure the correct uri is being provided for each test.
<img alt="Figure 5: Extract from routes file" src="img/07.png"></p>
<p>Here is a further test you may wish to run:</p>
<pre><code>
package app.test;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.List;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import app.model.Tweet;
import app.model.User;
import app.controllers.TweetsAPI;
import app.controllers.UsersAPI;


public class User_Tweet_Test
{
  User barney =  new User (&quot;barney&quot;,  &quot;gumble&quot;, &quot;barney@gumble.com&quot;,  &quot;secret&quot;);

  static User userArray [] = 
  { 
    new User (&quot;homer&quot;,  &quot;simpson&quot;, &quot;homer@simpson.com&quot;,  &quot;secret&quot;),
    new User (&quot;lisa&quot;,   &quot;simpson&quot;, &quot;lisa@simpson.com&quot;,   &quot;secret&quot;),
    new User (&quot;maggie&quot;, &quot;simpson&quot;, &quot;maggie@simpson.com&quot;, &quot;secret&quot;),
    new User (&quot;bart&quot;,   &quot;simpson&quot;, &quot;bart@simpson.com&quot;,   &quot;secret&quot;),
    new User (&quot;marge&quot;,  &quot;simpson&quot;, &quot;marge@simpson.com&quot;,  &quot;secret&quot;),
  };  

  List &lt;User&gt; userList = new ArrayList&lt;&gt;();

  /**
   * Create list of users
   */
  @Before
  public void setup() throws Exception
  { 
    for (User user : userArray)
    {
      User returned = UsersAPI.createUser(user);
      userList.add(returned);
    }
    UsersAPI.createUser(barney);
  }

  @Test
  public void testCreateTweets () throws Exception
  {
    Tweet tweet1 = new Tweet (&quot;cash&quot;, &quot;17-Nov-2014 12:45:53&quot;);
    Tweet tweet2 = new Tweet (&quot;cash&quot;, &quot;17-Nov-2014 12:45:53&quot;);
    Tweet tweet3 = new Tweet (&quot;paypal&quot;, &quot;17-Nov-2014 12:45:53&quot;);

    Tweet returnedTweet1 = TweetsAPI.createTweet(barney, tweet1);
    Tweet returnedTweet2 = TweetsAPI.createTweet(barney, tweet2);
    Tweet returnedTweet3 = TweetsAPI.createTweet(barney, tweet3);

    assertEquals(tweet1, returnedTweet1);
    assertEquals(tweet2, returnedTweet2);
    assertEquals(tweet3, returnedTweet3);

  }

}
</code></pre>

<p>Use Chrome Postman to verify the results as shown below in Figures 6 &amp; 7.</p>
<ul>
<li>Obviously any test you may run will have different UUIDs as these are randomly generated.</li>
</ul>
<p><img alt="Figure 6: List of Users" src="img/12.png"></p>
<p><img alt="Figure 7: List of Tweets for specific user (Barney Gumble)" src="img/13.png"></p>
</div>
<script>
$('.ui.menu .item')
  .tab({
    history: true,
    historyType: 'hash'
  })
;
  $('.ui.sticky')
  .sticky({
    bottomOffset : 50,
    context      : '#labcontent'
  })
;
</script>
   </div>



  <br><br>
  <div class="ui bottom fixed borderless menu">
    <div class="ui small item">
    <p id="footertext">
    Prepared by  Eamonn de Leastar (edeleastar@tssg.wit.ie) & John Fitzgerald (johnjfitzgerald@outlook.com). Except where otherwise noted, this content is licensed under a
     <a  href="http://creativecommons.org/licenses/by-nc/4.0/" title="External link to http://creativecommons.org/licenses/by-nc/4.0/"
       target="_blank">Creative Commons Attribution-NonCommercial 4.0 License
     </a>
     </p>
    </div>
  </div>    <script>

$(document).ready(function()
{
  $("img").addClass ("ui image");

  var images = $(".lab img");
  jQuery.each(images, function(i)  {
    if((images[i].alt).length > 0)
    {
      var div_img = $(document.createElement("div")).addClass("ui segment");
      $(images[i]).wrap(div_img);
      var div_label = $(document.createElement("div")).addClass("ui ribbon teal top attached label");
      div_label.append(images[i].alt);
      $(div_label).insertBefore(images[i]);
    }
  });
})    </script>

  </body>
 </html>